
from datetime import date, datetime, timedelta
from polars import DataFrame as DataFrame, Expr as Expr
from polars.datatypes import Array as Array, Boolean as Boolean, Categorical as Categorical, Date as Date, Datetime as Datetime, Decimal as Decimal, Duration as Duration, FLOAT_DTYPES as FLOAT_DTYPES, Float32 as Float32, Float64 as Float64, INTEGER_DTYPES as INTEGER_DTYPES, Int16 as Int16, Int32 as Int32, Int64 as Int64, Int8 as Int8, List as List, NUMERIC_DTYPES as NUMERIC_DTYPES, Object as Object, SIGNED_INTEGER_DTYPES as SIGNED_INTEGER_DTYPES, TEMPORAL_DTYPES as TEMPORAL_DTYPES, Time as Time, UInt32 as UInt32, UInt64 as UInt64, UNSIGNED_INTEGER_DTYPES as UNSIGNED_INTEGER_DTYPES, Unknown as Unknown, Utf8 as Utf8, dtype_to_ctype as dtype_to_ctype, is_polars_dtype as is_polars_dtype, maybe_cast as maybe_cast, numpy_char_code_to_dtype as numpy_char_code_to_dtype, py_type_to_dtype as py_type_to_dtype, supported_numpy_char_code as supported_numpy_char_code
from polars.dependencies import _PYARROW_AVAILABLE as _PYARROW_AVAILABLE, _check_for_numpy as _check_for_numpy, _check_for_pandas as _check_for_pandas, _check_for_pyarrow as _check_for_pyarrow, dataframe_api_compat as dataframe_api_compat, numpy as np, pandas as pd, pyarrow as pa
from polars.exceptions import ShapeError as ShapeError
from polars.polars import PyDataFrame as PyDataFrame, PySeries as PySeries
from polars.series._numpy import SeriesView as SeriesView
from polars.series.array import ArrayNameSpace as ArrayNameSpace
from polars.series.binary import BinaryNameSpace as BinaryNameSpace
from polars.series.categorical import CatNameSpace as CatNameSpace
from polars.series.datetime import DateTimeNameSpace as DateTimeNameSpace
from polars.series.list import ListNameSpace as ListNameSpace
from polars.series.string import StringNameSpace as StringNameSpace
from polars.series.struct import StructNameSpace as StructNameSpace
from polars.series.utils import expr_dispatch as expr_dispatch, get_ffi_func as get_ffi_func
from polars.slice import PolarsSlice as PolarsSlice
from polars.type_aliases import ClosedInterval as ClosedInterval, ComparisonOperator as ComparisonOperator, FillNullStrategy as FillNullStrategy, InterpolationMethod as InterpolationMethod, IntoExpr as IntoExpr, NullBehavior as NullBehavior, OneOrMoreDataTypes as OneOrMoreDataTypes, PolarsDataType as PolarsDataType, PythonLiteral as PythonLiteral, RankMethod as RankMethod, RollingInterpolationMethod as RollingInterpolationMethod, SearchSortedSide as SearchSortedSide, SizeUnit as SizeUnit, TimeUnit as TimeUnit
from polars.utils._construction import arrow_to_pyseries as arrow_to_pyseries, iterable_to_pyseries as iterable_to_pyseries, numpy_to_idxs as numpy_to_idxs, numpy_to_pyseries as numpy_to_pyseries, pandas_to_pyseries as pandas_to_pyseries, sequence_to_pyseries as sequence_to_pyseries, series_to_pyseries as series_to_pyseries
from polars.utils._wrap import wrap_df as wrap_df
from polars.utils.convert import _date_to_pl_date as _date_to_pl_date, _datetime_to_pl_timestamp as _datetime_to_pl_timestamp, _time_to_pl_time as _time_to_pl_time
from polars.utils.deprecation import deprecate_renamed_parameter as deprecate_renamed_parameter, issue_deprecation_warning as issue_deprecation_warning
from polars.utils.meta import get_index_type as get_index_type
from polars.utils.various import _is_generator as _is_generator, parse_version as parse_version, range_to_series as range_to_series, range_to_slice as range_to_slice, scale_bytes as scale_bytes, sphinx_accessor as sphinx_accessor
from typing import Any, Callable, ClassVar, Collection, Generator, NoReturn, Sequence, overload
from typing_extensions import Self

ArrayLike = Union[Sequence[Any], "Series", "pa.Array", "pa.ChunkedArray", "np.ndarray", "pd.Series", "pd.DatetimeIndex"]

class Series:
    _s: PySeries
    _accessors: ClassVar[set[str]]
    def __init__(self, name: str | ArrayLike | None = ..., values: ArrayLike | None = ..., dtype: PolarsDataType | None = ..., *, strict: bool = ..., nan_to_null: bool = ..., dtype_if_empty: PolarsDataType | None = ...) -> None: ...
    @classmethod
    def _from_pyseries(cls, pyseries: PySeries) -> Self: ...
    @classmethod
    def _from_arrow(cls, name: str, values: pa.Array, *, rechunk: bool = ...) -> Self: ...
    @classmethod
    def _from_pandas(cls, name: str, values: pd.Series[Any] | pd.DatetimeIndex, *, nan_to_null: bool = ...) -> Self: ...
    def _get_ptr(self) -> int: ...
    @property
    def dtype(self) -> PolarsDataType: ...
    @property
    def flags(self) -> dict[str, bool]: ...
    @property
    def inner_dtype(self) -> PolarsDataType | None: ...
    @property
    def name(self) -> str: ...
    @property
    def shape(self) -> tuple[int]: ...
    @property
    def time_unit(self) -> TimeUnit | None: ...
    def __bool__(self) -> NoReturn: ...
    def __getstate__(self) -> Any: ...
    def __setstate__(self, state: Any) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __and__(self, other: Series) -> Self: ...
    def __rand__(self, other: Series) -> Series: ...
    def __or__(self, other: Series) -> Self: ...
    def __ror__(self, other: Series) -> Self: ...
    def __xor__(self, other: Series) -> Self: ...
    def __rxor__(self, other: Series) -> Series: ...
    def _comp(self, other: Any, op: ComparisonOperator) -> Self: ...
    @overload
    def __eq__(self, other: Expr) -> Expr: ...
    @overload
    def __eq__(self, other: Any) -> Self: ...
    @overload
    def __ne__(self, other: Expr) -> Expr: ...
    @overload
    def __ne__(self, other: Any) -> Self: ...
    @overload
    def __gt__(self, other: Expr) -> Expr: ...
    @overload
    def __gt__(self, other: Any) -> Self: ...
    @overload
    def __lt__(self, other: Expr) -> Expr: ...
    @overload
    def __lt__(self, other: Any) -> Self: ...
    @overload
    def __ge__(self, other: Expr) -> Expr: ...
    @overload
    def __ge__(self, other: Any) -> Self: ...
    @overload
    def __le__(self, other: Expr) -> Expr: ...
    @overload
    def __le__(self, other: Any) -> Self: ...
    def le(self, other: Any) -> Self | Expr: ...
    def lt(self, other: Any) -> Self | Expr: ...
    def eq(self, other: Any) -> Self | Expr: ...
    @overload
    def eq_missing(self, other: Any) -> Self: ...
    @overload
    def eq_missing(self, other: Expr) -> Expr: ...
    def ne(self, other: Any) -> Self | Expr: ...
    @overload
    def ne_missing(self, other: Expr) -> Expr: ...
    @overload
    def ne_missing(self, other: Any) -> Self: ...
    def ge(self, other: Any) -> Self | Expr: ...
    def gt(self, other: Any) -> Self | Expr: ...
    def _arithmetic(self, other: Any, op_s: str, op_ffi: str) -> Self: ...
    @overload
    def __add__(self, other: DataFrame) -> DataFrame: ...
    @overload
    def __add__(self, other: Expr) -> Expr: ...
    @overload
    def __add__(self, other: Any) -> Self: ...
    @overload
    def __sub__(self, other: Expr) -> Expr: ...
    @overload
    def __sub__(self, other: Any) -> Self: ...
    @overload
    def __truediv__(self, other: Expr) -> Expr: ...
    @overload
    def __truediv__(self, other: Any) -> Series: ...
    @overload
    def __floordiv__(self, other: Expr) -> Expr: ...
    @overload
    def __floordiv__(self, other: Any) -> Series: ...
    def __invert__(self) -> Self: ...
    @overload
    def __mul__(self, other: Expr) -> Expr: ...
    @overload
    def __mul__(self, other: DataFrame) -> DataFrame: ...
    @overload
    def __mul__(self, other: Any) -> Series: ...
    @overload
    def __mod__(self, other: Expr) -> Expr: ...
    @overload
    def __mod__(self, other: Any) -> Series: ...
    def __rmod__(self, other: Any) -> Series: ...
    def __radd__(self, other: Any) -> Series: ...
    def __rsub__(self, other: Any) -> Series: ...
    def __rtruediv__(self, other: Any) -> Series: ...
    def __rfloordiv__(self, other: Any) -> Series: ...
    def __rmul__(self, other: Any) -> Series: ...
    def __pow__(self, exponent: int | float | None | Series) -> Series: ...
    def __rpow__(self, other: Any) -> Series: ...
    def __matmul__(self, other: Any) -> float | Series | None: ...
    def __rmatmul__(self, other: Any) -> float | Series | None: ...
    def __neg__(self) -> Series: ...
    def __pos__(self) -> Series: ...
    def __abs__(self) -> Series: ...
    def __copy__(self) -> Self: ...
    def __deepcopy__(self, memo: None = ...) -> Self: ...
    def __contains__(self, item: Any) -> bool: ...
    def __iter__(self) -> Generator[Any, None, None]: ...
    def _pos_idxs(self, size: int) -> Series: ...
    def _take_with_series(self, s: Series) -> Series: ...
    @overload
    def __getitem__(self, item: int) -> Any: ...
    @overload
    def __getitem__(self, item: Series | range | slice | np.ndarray[Any, Any] | list[int]) -> Series: ...
    def __setitem__(self, key: int | Series | np.ndarray[Any, Any] | Sequence[object] | tuple[object], value: Any) -> None: ...
    def __array__(self, dtype: Any = ...) -> np.ndarray[Any, Any]: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs: Any, **kwargs: Any) -> Series: ...
    def __column_consortium_standard__(self, *, api_version: str | None = ...) -> Any: ...
    def _repr_html_(self) -> str: ...
    def item(self, row: int | None = ...) -> Any: ...
    def estimated_size(self, unit: SizeUnit = ...) -> int | float: ...
    def sqrt(self) -> Series: ...
    def cbrt(self) -> Series: ...
    def any(self, drop_nulls: bool = ...) -> bool | None: ...
    def all(self, drop_nulls: bool = ...) -> bool | None: ...
    def log(self, base: float = ...) -> Series: ...
    def log1p(self) -> Series: ...
    def log10(self) -> Series: ...
    def exp(self) -> Series: ...
    def drop_nulls(self) -> Series: ...
    def drop_nans(self) -> Series: ...
    def to_frame(self, name: str | None = ...) -> DataFrame: ...
    def describe(self, percentiles: Sequence[float] | float | None = ...) -> DataFrame: ...
    def sum(self) -> int | float: ...
    def mean(self) -> int | float | None: ...
    def product(self) -> int | float: ...
    def pow(self, exponent: int | float | None | Series) -> Series: ...
    def min(self) -> PythonLiteral | None: ...
    def max(self) -> PythonLiteral | None: ...
    def nan_max(self) -> int | float | date | datetime | timedelta | str: ...
    def nan_min(self) -> int | float | date | datetime | timedelta | str: ...
    def std(self, ddof: int = ...) -> float | None: ...
    def var(self, ddof: int = ...) -> float | None: ...
    def median(self) -> float | None: ...
    def quantile(self, quantile: float, interpolation: RollingInterpolationMethod = ...) -> float | None: ...
    def to_dummies(self, separator: str = ...) -> DataFrame: ...
    def cut(self, breaks: list[float], labels: list[str] | None = ..., break_point_label: str = ..., category_label: str = ..., *, series: bool = ..., left_closed: bool = ..., include_breaks: bool = ...) -> DataFrame | Series: ...
    def qcut(self, quantiles: list[float] | int, *, labels: list[str] | None = ..., break_point_label: str = ..., category_label: str = ..., series: bool = ..., left_closed: bool = ..., allow_duplicates: bool = ..., include_breaks: bool = ...) -> DataFrame | Series: ...
    def rle(self) -> Series: ...
    def rle_id(self) -> Series: ...
    def hist(self, bins: list[float] | None = ..., *, bin_count: int | None = ...) -> DataFrame: ...
    def value_counts(self, *, sort: bool = ...) -> DataFrame: ...
    def unique_counts(self) -> Series: ...
    def entropy(self, base: float = ..., *, normalize: bool = ...) -> float | None: ...
    def cumulative_eval(self, expr: Expr, min_periods: int = ..., *, parallel: bool = ...) -> Series: ...
    def alias(self, name: str) -> Series: ...
    def rename(self, name: str, *, in_place: bool | None = ...) -> Series: ...
    def chunk_lengths(self) -> list[int]: ...
    def n_chunks(self) -> int: ...
    def cummax(self, *, reverse: bool = ...) -> Series: ...
    def cummin(self, *, reverse: bool = ...) -> Series: ...
    def cumprod(self, *, reverse: bool = ...) -> Series: ...
    def cumsum(self, *, reverse: bool = ...) -> Series: ...
    def slice(self, offset: int, length: int | None = ...) -> Series: ...
    def append(self, other: Series, *, append_chunks: bool | None = ...) -> Self: ...
    def extend(self, other: Series) -> Self: ...
    def filter(self, predicate: Series | list[bool]) -> Self: ...
    def head(self, n: int = ...) -> Series: ...
    def tail(self, n: int = ...) -> Series: ...
    def limit(self, n: int = ...) -> Series: ...
    def take_every(self, n: int) -> Series: ...
    def sort(self, *, descending: bool = ..., in_place: bool = ...) -> Self: ...
    def top_k(self, k: int = ...) -> Series: ...
    def bottom_k(self, k: int = ...) -> Series: ...
    def arg_sort(self, *, descending: bool = ..., nulls_last: bool = ...) -> Series: ...
    def arg_unique(self) -> Series: ...
    def arg_min(self) -> int | None: ...
    def arg_max(self) -> int | None: ...
    @overload
    def search_sorted(self, element: int | float, side: SearchSortedSide = ...) -> int: ...
    @overload
    def search_sorted(self, element: Series | np.ndarray[Any, Any] | list[int] | list[float], side: SearchSortedSide = ...) -> Series: ...
    def unique(self, *, maintain_order: bool = ...) -> Series: ...
    def take(self, indices: int | list[int] | Expr | Series | np.ndarray[Any, Any]) -> Series: ...
    def null_count(self) -> int: ...
    def has_validity(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def is_sorted(self, *, descending: bool = ...) -> bool: ...
    def is_null(self) -> Series: ...
    def is_not_null(self) -> Series: ...
    def is_finite(self) -> Series: ...
    def is_infinite(self) -> Series: ...
    def is_nan(self) -> Series: ...
    def is_not_nan(self) -> Series: ...
    def is_in(self, other: Series | Collection[Any]) -> Series: ...
    def arg_true(self) -> Series: ...
    def is_unique(self) -> Series: ...
    def is_first(self) -> Series: ...
    def is_duplicated(self) -> Series: ...
    def explode(self) -> Series: ...
    def series_equal(self, other: Series, *, null_equal: bool = ..., strict: bool = ...) -> bool: ...
    def len(self) -> int: ...
    def cast(self, dtype: PolarsDataType | type[int] | type[float] | type[str] | type[bool], *, strict: bool = ...) -> Self: ...
    def to_physical(self) -> Series: ...
    def to_list(self, *, use_pyarrow: bool = ...) -> list[Any]: ...
    def rechunk(self, *, in_place: bool = ...) -> Self: ...
    def reverse(self) -> Series: ...
    def is_between(self, lower_bound: IntoExpr, upper_bound: IntoExpr, closed: ClosedInterval = ...) -> Series: ...
    def is_numeric(self) -> bool: ...
    def is_integer(self, signed: bool | None = ...) -> bool: ...
    def is_temporal(self, excluding: OneOrMoreDataTypes | None = ...) -> bool: ...
    def is_float(self) -> bool: ...
    def is_boolean(self) -> bool: ...
    def is_utf8(self) -> bool: ...
    def view(self, *, ignore_nulls: bool = ...) -> SeriesView: ...
    def to_numpy(self, *args: Any, zero_copy_only: bool = ..., writable: bool = ..., use_pyarrow: bool = ...) -> np.ndarray[Any, Any]: ...
    def to_arrow(self) -> pa.Array: ...
    def to_pandas(self, *args: Any, use_pyarrow_extension_array: bool = ..., **kwargs: Any) -> pd.Series[Any]: ...
    def to_init_repr(self, n: int = ...) -> str: ...
    def set(self, filter: Series, value: int | float | str) -> Series: ...
    def set_at_idx(self, idx: Series | np.ndarray[Any, Any] | Sequence[int] | int, value: int | float | str | bool | Sequence[int] | Sequence[float] | Sequence[bool] | Sequence[str] | Sequence[date] | Sequence[datetime] | date | datetime | Series | None) -> Series: ...
    def clear(self, n: int = ...) -> Series: ...
    def clone(self) -> Self: ...
    def fill_nan(self, value: int | float | Expr | None) -> Series: ...
    def fill_null(self, value: Any | None = ..., strategy: FillNullStrategy | None = ..., limit: int | None = ...) -> Series: ...
    def floor(self) -> Series: ...
    def ceil(self) -> Series: ...
    def round(self, decimals: int = ...) -> Series: ...
    def dot(self, other: Series | ArrayLike) -> float | None: ...
    def mode(self) -> Series: ...
    def sign(self) -> Series: ...
    def sin(self) -> Series: ...
    def cos(self) -> Series: ...
    def tan(self) -> Series: ...
    def arcsin(self) -> Series: ...
    def arccos(self) -> Series: ...
    def arctan(self) -> Series: ...
    def arcsinh(self) -> Series: ...
    def arccosh(self) -> Series: ...
    def arctanh(self) -> Series: ...
    def sinh(self) -> Series: ...
    def cosh(self) -> Series: ...
    def tanh(self) -> Series: ...
    def apply(self, function: Callable[[Any], Any], return_dtype: PolarsDataType | None = ..., *, skip_nulls: bool = ...) -> Self: ...
    def shift(self, periods: int = ...) -> Series: ...
    def shift_and_fill(self, fill_value: int | Expr, *, periods: int = ...) -> Series: ...
    def zip_with(self, mask: Series, other: Series) -> Self: ...
    def rolling_min(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_max(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_mean(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_sum(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_std(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ..., ddof: int = ...) -> Series: ...
    def rolling_var(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ..., ddof: int = ...) -> Series: ...
    def rolling_apply(self, function: Callable[[Series], Any], window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_median(self, window_size: int, weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_quantile(self, quantile: float, interpolation: RollingInterpolationMethod = ..., window_size: int = ..., weights: list[float] | None = ..., min_periods: int | None = ..., *, center: bool = ...) -> Series: ...
    def rolling_skew(self, window_size: int, *, bias: bool = ...) -> Series: ...
    def sample(self, n: int | None = ..., *, fraction: float | None = ..., with_replacement: bool = ..., shuffle: bool = ..., seed: int | None = ...) -> Series: ...
    def peak_max(self) -> Self: ...
    def peak_min(self) -> Self: ...
    def n_unique(self) -> int: ...
    def shrink_to_fit(self, *, in_place: bool = ...) -> Series: ...
    def hash(self, seed: int = ..., seed_1: int | None = ..., seed_2: int | None = ..., seed_3: int | None = ...) -> Series: ...
    def reinterpret(self, *, signed: bool = ...) -> Series: ...
    def interpolate(self, method: InterpolationMethod = ...) -> Series: ...
    def abs(self) -> Series: ...
    def rank(self, method: RankMethod = ..., *, descending: bool = ..., seed: int | None = ...) -> Series: ...
    def diff(self, n: int = ..., null_behavior: NullBehavior = ...) -> Series: ...
    def pct_change(self, n: int = ...) -> Series: ...
    def skew(self, *, bias: bool = ...) -> float | None: ...
    def kurtosis(self, *, fisher: bool = ..., bias: bool = ...) -> float | None: ...
    def clip(self, lower_bound: int | float, upper_bound: int | float) -> Series: ...
    def clip_min(self, lower_bound: int | float) -> Series: ...
    def clip_max(self, upper_bound: int | float) -> Series: ...
    def lower_bound(self) -> Self: ...
    def upper_bound(self) -> Self: ...
    def map_dict(self, remapping: dict[Any, Any], *, default: Any = ..., return_dtype: PolarsDataType | None = ...) -> Self: ...
    def reshape(self, dimensions: tuple[int, ...]) -> Series: ...
    def shuffle(self, seed: int | None = ...) -> Series: ...
    def ewm_mean(self, com: float | None = ..., span: float | None = ..., half_life: float | None = ..., alpha: float | None = ..., *, adjust: bool = ..., min_periods: int = ..., ignore_nulls: bool = ...) -> Series: ...
    def ewm_std(self, com: float | None = ..., span: float | None = ..., half_life: float | None = ..., alpha: float | None = ..., *, adjust: bool = ..., bias: bool = ..., min_periods: int = ..., ignore_nulls: bool = ...) -> Series: ...
    def ewm_var(self, com: float | None = ..., span: float | None = ..., half_life: float | None = ..., alpha: float | None = ..., *, adjust: bool = ..., bias: bool = ..., min_periods: int = ..., ignore_nulls: bool = ...) -> Series: ...
    def extend_constant(self, value: PythonLiteral | None, n: int) -> Series: ...
    def set_sorted(self, *, descending: bool = ...) -> Self: ...
    def new_from_index(self, index: int, length: int) -> Self: ...
    def shrink_dtype(self) -> Series: ...
    def get_chunks(self) -> list[Series]: ...
    def implode(self) -> Self: ...
    @property
    def bin(self) -> BinaryNameSpace: ...
    @property
    def cat(self) -> CatNameSpace: ...
    @property
    def dt(self) -> DateTimeNameSpace: ...
    @property
    def list(self) -> ListNameSpace: ...
    @property
    def arr(self) -> ArrayNameSpace: ...
    @property
    def str(self) -> StringNameSpace: ...
    @property
    def struct(self) -> StructNameSpace: ...

def _resolve_datetime_dtype(dtype: PolarsDataType | None, ndtype: np.datetime64) -> PolarsDataType | None: ...
