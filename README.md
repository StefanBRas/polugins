# Polugins

Minimal "plugin" system for polars.

It's meant to solve two issues with using polars API extensions:

- You need to import the namespace to trigger the registration, even if you do not need anything from the namespace module.

- Extensions breaks static typing.

Polugins exposes some standard ways to use API extensions - both for your own and third party packages - 
and then use this discoverability to also generate type stubs with the added typing from the extensions.

Users can either call `register_namespaces` themselves or import polars through `polugins.polars` instead.
Lint rules can then be used to enforce that nothing is imported from polars outside of these locations.

Types are generated with the package `polugins_type_gen`.

## Usage example

Namespaces can be registered in five ways:

- By module path
- As imported module
- From entry points
- From a configuration (pyproject.toml or polugins.toml)
- From environment variables

Say that you have a package `my_package` with two `LazyFrame` namespaces - `MyNamespace` and `AlsoMyNamespace` and you use an
external package `example-package` that exposes a `LazyFrame` namespace called `external`.
After installing it, namespaces can be registered like so:

```python
from polugins import register_namespaces
import polars as pl
from my_package import MyNamespace

register_namespaces(
    lazyframe_namespaces={
        'my_namespace': MyNamespace,
        'also_my_namespace': "my_package:AlsoMyNamespace" # Note the `:` to separate module path from object
    },
    load_entrypoints=True # Loads from example-package
    load_config=True # Loads from pyproject.toml and polugins.toml
    load_env=True # Loads from environment variables
  )

# All namespaces are now registered
(
  pl.LazyFrame()
  .external.some_method()
  .my_namespace.some_method()
  .also_my_namespace.some_method()
)
```

You need to make sure that you have called `register_namespaces` before trying to use any of those namespaces.

As an alternative, polars is re-exported through `polugins` such that entrypoint, configuration and environment variable namespaces are automagically registered:

```python
from polugins import pl

pl.LazyFrame().external.some_method(x=1)
```


## Generate types

Run `polugins_type_gen stubs` to create type stubs at "./typings".

## Third party Package example

Packages can expose namespace through entry points called `polugins.<class>`, for example `polugins.lazyframe`.

If building with poetry you should add this to your `pyproject.toml`:

```toml
[tool.poetry.plugins."polugins.<class>"]
"<accessor_name>" = "<path.to.module:NameSpace>"

# Concrete example:

[tool.poetry.plugins."polugins.lazyframe"]
"external" = "example_package:PackageNamespace"
```

See `tests/pkgs/example_package` for a example.


## Implementation

Just a thin wrapper around `polars.api.register_x_namespace` and then using `importlib.metadata` to collect
namespaces from external packages.

Types are generated by using mypy to create stubs for lazyframe, dataframe, expr and series and then adding the
namespaces to these type stubs.

